import { AckPolicy, jetstream, jetstreamManager } from '@nats-io/jetstream'
import { Kvm } from '@nats-io/kv'
import { connect } from '@nats-io/transport-node'
import { type CommitEvent } from '@skyware/jetstream'
import { recordIdToKey } from './util.ts'

// This process consumes the firehose ingest buffer generated by ingest.ts
// into the contents of the record kv store. It's not needed today, but this
// process can be scaled horizontally since the ingest stream is partitioned.

type KvOptions = {
  host?: string
}

export async function createKvBuilder(opts: KvOptions = {}) {
  const connection = await connect({ servers: opts.host })
  const js = jetstream(connection)
  const jsm = await jetstreamManager(connection)
  const recordkv = await new Kvm(js).create('record', { history: 1 })
  await jsm.consumers.add('ingest', {
    durable_name: 'ingest-kv-consumer',
    ack_policy: AckPolicy.Explicit,
  })
  const consumer = await js.consumers.get('ingest', 'ingest-kv-consumer')
  const messages = await consumer.consume()
  for await (const item of messages) {
    const { did, commit } = item.json<CommitEvent<string>>()
    const { collection, rkey } = commit
    const partition = item.subject.split('.').pop()!
    if (commit.operation === 'create' || commit.operation === 'update') {
      await recordkv.put(
        recordIdToKey({ did, collection, rkey, partition }),
        JSON.stringify(commit.record),
      )
    } else if (commit.operation === 'delete') {
      await recordkv.delete(recordIdToKey({ did, collection, rkey, partition }))
    }
    item.ack()
  }
}

// start if run directly, e.g. node kv.ts
if (import.meta.url === `file://${process.argv[1]}`) {
  createKvBuilder()
}
